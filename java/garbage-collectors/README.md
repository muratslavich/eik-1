# Garbage collectors

* young generation
* old generation



* minor GC - часто, только young generation
* full GC - редко, когда заканчивается память



Разделение на поколения физическое, они размещаются в разных регионах памяти



* stop-the-world - максимальное время остановки
* пропускная способность - отношение общего времени работы к stw, определяет способность работать под пиковой нагрузкой
* потребляемые ресурсы



Мертвые объекты

* для малой сборки - нет ссылок из old generation ни из roots
* для полной сборки - нет ссылок от roots

Roots - стэки потоков, статические члены.



HotSpot мониторинг флаги

<table data-header-hidden><thead><tr><th width="250.37791932059451"></th><th></th></tr></thead><tbody><tr><td><em>-verbose:gc</em></td><td>Включает режим логирования сборок мусора в stdout.</td></tr><tr><td><em>-Xloggc:filename</em></td><td>Указывает имя файла, в который должна логироваться информация о сборках мусора. Имеет приоритет над <em>-verbose:gc</em>.</td></tr><tr><td><em>-XX:+PrintGCTimeStamps</em></td><td>Добавляет к информации о сборках временные метки (в виде количества секунд, прошедших с начала работы программы).</td></tr><tr><td><em>-XX:+PrintGCDetails</em></td><td>Включает расширенный вывод информации о сборках мусора.</td></tr><tr><td><em>-XX:+PrintFlagsFinal</em></td><td>При старте приложения выводит в stdout значения всех опций, заданных явно или установленных самой JVM. Сюда же попадают опции, относящиеся к сборке мусора. Часто бывает полезно посмотреть на присвоенные им значения.</td></tr></tbody></table>



Мониторинг

* VisualVM
* Java MissionControl
* JProfiler
* YourKit



Сборщики HotSpotVm

* Serial
* Parallel
* Concurrent Mark Sweep - снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения.
* G1 garbage-first



JVM может запрашивать или возвращать память ОС при необходимости

* Xms - начально аллоцируемая JVM объем памяти
* Xmx - максимальный объем памяти





<details>

<summary><em>-XX:+UseSerialGC</em></summary>

Если вашему приложению не требуется большой размер кучи для работы (Oracle указывает условную границу 100 МБ), оно не очень чувствительно к коротким остановкам и ему для работы доступно только одно ядро процессора, то можно приглядеться к этому варианту.



По умолчанию младшее поколение занимает 1/3 всего пространства

При этом каждый survivor это 1/10 от младшего

![](<../.gitbook/assets/image (10).png>)

_Плохо работает с большой кучей, не использует многопроцессорность._

Heap физически разделен на 4 части

<img src="../.gitbook/assets/image (12).png" alt="" data-size="original">





**Малая сборка** очищает объекты из eden, оставшиеся переносит в survivor. Один из surivor s0 или s1 всегда пустой.

<img src="../.gitbook/assets/image (13).png" alt="" data-size="original">

Следующая малая сборка освободит уже eden и s0 и перенесет их в s1

<img src="../.gitbook/assets/image (5).png" alt="" data-size="original">

Для следующие сборки выжившие объекты обратно переместятся в s0, так до тех пор пока в регионах survivor достаточно места

<img src="../.gitbook/assets/image (6).png" alt="" data-size="original">

Если survivor заполнен или после определенного количества перемещений объекты отправляются в tenured

<img src="../.gitbook/assets/image (14).png" alt="" data-size="original">

Когда для новых объектов места уже не хватает в tenured проводится полная сборка. В tenured секторе происходит уплотнение, а не перенос как до этого.

<img src="../.gitbook/assets/image (4).png" alt="" data-size="original">

**Mark-Sweep-Compact -** пометить, очистить, уплотнить

Крупные объекты, которые слишком накладно копировать в survivor создаются сразу в tenured





В случае, если даже после выделения максимального объема памяти и ее полной чистки, места для новых объектов так и не находится, мы ожидаемо получаем _java.lang.OutOfMemoryError: Java heap space_ и приложение прекращает работу, оставляя нам на память свою кучу в виде файла для анализа. Технически, это происходит в случае, если работа сборщика начинает занимать не менее 98% времени и при этом сборки мусора освобождают не более 2% памяти.



Stop-the-world

В начале каждой сборке, работа всех потоков прекращается, сборка происходит в одном отдельном потоке



_-XX:MinHeapFreeRatio=?_ и _-XX:MaxHeapFreeRatio=?_

* минимальная и максимальная доля свободного места в каждом поколении, при достижении которого JVM попытается увеличить или уменьшить его размер

_-XX:NewRatio=?_

* желаемое отношение размера старшего поколения к суммарному размеру регионов младшего поколения
* Например, _NewRatio=3_ означает, что для младшего поколения (Eden + S0 + S1) будет отведена четверть кучи, а для старшего — три четверти. Контринтуитивное название этой опции вносит некоторую путаницу даже в документацию Oracle, но работает она именно так. Тут проще запомнить, что там, где названия опций заканчиваются на _Ratio_, реальная величина будет обратной той, что вы указали.

_-XX:NewSize=?_ и _-XX:MaxNewSize=?_

* можно ограничить размер младшего поколения абсолютными величинами снизу и сверху
* если вы хотите установить для _NewSize_ и _MaxNewSize_ одинаковые значения, то можно просто использовать опцию _-Xmn_. Например, _-Xmn256m_ эквивалентно _-XX:NewSize=256m -XX:MaxNewSize=256m_.

_-XX:SurvivorRatio=?_

* отношение размера Eden к размерам Survivor
* Например, при _SurvivorRatio=6_ каждый регион Survivor будет занимать одну восьмую размера всего младшего поколения, а Eden — шесть восьмых&#x20;

_-XX:-UseGCOverheadLimit_

* отключить порог активности сборщика в 98%, при достижении которого возникает OutOfMemoryError

_-XX:+PrintTenuringDistribution_

* добавляет статистику по Survivor к выводу информации о некоторых сборках мусора.

</details>

<details>

<summary><em>-XX:+UseParallelGC</em></summary>

* сборкой мусора занимаются несколько потоков параллельно;&#x20;
* во-вторых, данный сборщик может самостоятельно подстраиваться под требуемые параметры производительности.



Каждый поток сборщика получает свой участок памяти в регионе Old Gen, так называемый _буфер повышения (promotion buffer)_, куда только он может переносить данные, чтобы не мешать другим потокам. Такой подход ускоряет сборку мусора, но имеет и небольшое негативное последствие в виде возможной фрагментации памяти

![](<../.gitbook/assets/image (11).png>)

В случае, если вы задали слишком жесткие требования, которые сборщик не может выполнить, он будет ориентироваться на следующие приоритеты (в порядке убывания важности):

1. Снижение максимальной паузы.
2. Повышение пропускной способности.
3. Минимизация используемой памяти.

При этом Parallel GC оставляет нам возможность самостоятельно корректировать размеры регионов, как и в последовательном сборщике. Но не рекомендуется делать и то и другое одновременно, чтобы не дезориентировать алгоритмы автоматической подстройки. Либо мы выделяем приложению достаточно памяти, указываем желаемые параметры производительности и наблюдаем со стороны, либо сами залезаем в настройки регионов, но тогда лишаемся права требовать от сборщика автоматической подстройки под нужные нам критерии производительности.&#x20;



Все те же настройки что у serialGC плюс:

_-XX:ParallelGCThreads=?_

* количество потоков, которое хотели бы выделить для сборки мусора
* Имейте в виду, что увеличение количества потоков не только сильнее распараллеливает сборку, но и увеличивает фрагментацию региона Tenured, а также добавляет накладные расходы на синхронизацию этих потоков.

_-XX:-UseParallelOldGC_

* полностью отключить параллельные работы по уплотнению объектов в старшем поколении

_-XX:MaxGCPauseMillis=?_

* ограничение на максимальное время приостановки программы для сборки мусора

_-XX:GCTimeRatio=?_

* желаемый порог пропускной способности (отношения времени работы программы ко времени сборки мусора)

_-XX:YoungGenerationSizeIncrement=?_ и _-XX:TenuredGenerationSizeIncrement=?_

* на сколько процентов следует при необходимости увеличивать младшее и старшее поколение соотвественно. По умолчанию оба этих параметра равны 20.

_-XX:AdaptiveSizeDecrementScaleFactor_

* во сколько раз уменьшение должно быть меньше увеличения



возможность автоматической подстройки под требуемые параметры производительности и меньшие паузы на время cборок. При наличии нескольких процессорных ядер выигрыш в скорости будет практически во всех приложениях.

Определенная фрагментация памяти, конечно, является минусом, но вряд ли она будет существенной для большинства приложений, так как сборщиком используется относительно небольшое количество потоков.

</details>

<details>

<summary><em>-XX:+UseConcMarkSweepGC</em></summary>

Mark-Sweep это пометка живых удаление в  tenured секторе

concurent-mark-sweep делает это в отдельном потоке во время выполнения программы

CMS не уплотняет объекты в tenured что приводит к фрагментации

Наличие плавающих мертвых объектов и отсутствие уплотнения приводит к необходимости выделять больше памяти (на 20% по доке Оракла)



Структура памяти та же, что и раньше

* &#x20;eden + s0 + s1 + tenured
* малая сборка работает так же
* вместо полной сборки - major  сборка - она не затрагивает младшее поколение
* сборка младшего и старшего поколения всегда разделена
* &#x20;major сборка не дожидается заполнения tenured а выполняется в фоновом режиме



Старшая сборка работает в две stw остановки

![](<../.gitbook/assets/image (3).png>)

Начинается она с остановки основных потоков приложения и пометки всех объектов, напрямую доступных из корней. После этого приложение возобновляет свою работу, а сборщик параллельно с ним производит поиск всех живых объектов, доступных по ссылкам из тех самых помеченных корневых объектов (эту часть он делает в одном или в нескольких потоках).\
\
Естественно, за время такого поиска ситуация в куче может поменяться, и не вся информация, собранная во время поиска живых объектов, оказывается актуальной. Поэтому сборщик еще раз приостанавливает работу приложения и просматривает кучу для поиска живых объектов, ускользнувших от него за время первого прохода. При этом допускается, что в живые будут записаны объекты, которые на время окончания составления списка таковыми уже не являются. Эти объекты называются _плавающим мусором (floating garbage)_, они будут удалены в процессе следующей сборки.\
\
После того, как живые объекты помечены, работа основных потоков приложения возобновляется, а сборщик производит очистку памяти от мертвых объектов в нескольких параллельных потоках. При этом следует иметь в виду, что после очистки не производится упаковка объектов в старшем поколении, так как делать это при работающем приложении весьма затруднительно.\


* сборщик старается разносить во времени minor и major сборки, чтобы сократить паузы
* если major сборка не успевает освободить tenured то происходит сбой параллельного режима _concurrent mode failure,_  работа приложения останавливается и сборка проходит в последовательном режиме



_-XX:CMSInitiatingOccupancyFraction=?_

* Обычно CMS, основываясь на собираемой статистике о поведении приложения, сам определяет, когда ему выполнять старшую сборку, но у него также есть порог наполненности региона Tenured, при достижении которого должна обязательно быть инициирована старшая сборка. в процентах
* \-1 по умолчанию - отключено

</details>

<details>

<summary>-XX:+UseG1GC</summary>

Предсказуемые размеры пауз особенно при больших размерах кучи

* для размера кучи от 4гб
* предсказуемое время отклика в ущерб пропускной способности
* не фрагментирует память

Организация памяти

<img src="../.gitbook/assets/image (7).png" alt="" data-size="original">

* множество регионов одинакового размера&#x20;
* размер регионов зависит от общего размера кучи, обычно на всю кучу не более 2048 регионов
* Громадные humogous регионы, объединение обычных регионов для хранения больших объектоа
  * объект больше половины размера региона
  * никогда не перемещается между регионами
  * может удаляться в рамках цикла
  * в регион занятый громадным объектом никого больше не подселяют
* eden survivor и tenured размещаются логически и не обязаны быть по порядку



Сборки

* малая сборка&#x20;
  * выполняются периодически с stw остановкой, не отличаются от предыдущих
  * очистка младшего поколения и перенос объектов в survivor или tenured
  * работает в несколько потоков
  * сборка происходит только над определенным количество регионов, чтобы не превышать желаемого времени остановки
  * при этом сборка происходит над теми регионам, в которых по мнению jvm скопилось наибольшее количество мусора
* mixed сборка
  * цикл пометки marking cycle -&#x20;
    * работает параллельно с основным приложением
    * initial mark - stw и пометка корней
    * concurrent marking - пометка всех живых объектов в куче, параллельно с работой приложения
    * remark - stw и поиск неучтенных живых объектов
    * cleanup - stw очистка структур хранения ссылок и поиcк пустых регионов
  * после окончания цикла пометки jvm переключается на смешанные сборки
    * при каждой сборке к набору регионов младшего поколения, добавляется некоторое количество регионов старшего поколения
    * как только освобождено достаточно памяти, сборщик переключается обратно в режим малых сборок
  * очередной цикл пометки и режим смешанных сборок будет запущен после того как заполненность кучи превысит порог

![](<../.gitbook/assets/image (2).png>)

* в процессе сборки может не оказаться свободных регионов  - allocation (evacuation) failure - при этом выполняется полная сборка с остановкой



_-XX:MaxGCPauseMillis=?_

* максимальное приемлемое время одной сборки

_-XX:ParallelGCThreads=?_ и _-XX:ConcGCThreads=?_&#x20;

* количество потоков для сборки и циклов пометки

_-XX:G1HeapRegionSize=?_

* размер региона - дб степенью двойки, например 16m (мегабайт)

_-XX:InitiatingHeapOccupancyPercent=?_

* порог заполненности кучи в процентах - по умолчанию 45

_-XX:+UnlockExperimentalVMOptions_ и _-XX:+AggressiveOpts_

* экспериментальные настройки

</details>
