# Inner Classes



1. **Внутренний класс (класс в классе)**
2. **Локальный внутренний класс (класс в определенный локально в отдельном методе)**
3. **Анонимный внутренний класс (класс определенный локально и без имени(если требуется создать единственный объект этого класса))**
4. **Статический внутренний класс (Внутренний класс без ссылок на объект внешнего класса)**
5. **Прокси-класс (Класс посредник)**

\
\
**1.Внутренний класс (класс в классе)Зачем он нужен**

* Объект внутреннего класса имеет доступ к данным объекта, в котором он определен, включая закрытые данные.Для этого нужно ему нужно содержать ссылку на объект внешнего класса (присутствует неявно)компилятор видоизменяет все конструкторы внутреннего класса, добавляя параметр для ссылки на внешний классесли конструкторы не определены, то компилятор автоматически формирует конструктор без аргументовПрименение внутреннего класса лишает необходимости предоставлять специальный метод доступа, представляющий интерес только для другого класса
* Внутренний класс можно скрыть от других классов того же пакета.
* Анонимный внутренний класс удобен, когда требуется определить обратный вызов в процессе выполнения программы, без необходимости писать много кода.

\




&#x20;         \


![](https://www.evernote.com/shard/s696/res/7810a55d-3346-44c5-92e7-91565012206b)

* Класс TimePrinter расположен в классе TalkingClock. Но это не значит, что каждый экземпляр класса TalkingClock содержит поле типа TimePrinter.
* Объекты типа TimePrinter создаются методами из класса TalkingClock
* Внутренний класс можно было объявить как _**private**_, и тогда его объекты смогут создавать методы только внешнего класса
* Внешняя ссылка _ВнешнийКласс.this_

\


![](https://www.evernote.com/shard/s696/res/99d64eb9-c1dc-4e27-a8b6-ef072987a64d)

* Конструктор внутреннего класса можно записать явным образом использую синтаксис: _ОбъектВнешнегоКласса.new   ВнутреннийКласс(параметры)_

![](https://www.evernote.com/shard/s696/res/a95b5b88-26ba-4900-8cf2-ccf13c27298f)

* Явное указание this здесь излишне. Это позволяет явно указать другой объект в ссылке на объект внешнего класса.
* Если ссылка на внутренний класс делается за пределами внешнего класса: _ВнешнийКласс.ВнутреннийКласс_

&#x20;&#x20;



\


* Обращение с внутренними классами происходит на уровне компилятора. Для их обозначения используется $, разделяющий имена внешних и внутренних классов
* Для виртуальной машины внутренние классы неотличимы от внешних TalkingClock$TimePrinter
* Компилятор генерирует дополнительное поле _this$0_ для ссылки на внешний класс
* У конструктора задается параметр _ВнешнийКласс_

&#x20;   &#x20;

![](https://www.evernote.com/shard/s696/res/2b5bf085-e8f1-4c7b-b4e6-88c391e39b37)

* Виртуальной машине ничего не известно о внутренних классах, для нее они ничем не отличаются

![](https://www.evernote.com/shard/s696/res/1841512e-8eb4-4390-8ac7-b188a261106c)

* Компилятор добавляет во внешний класс статический метод _acess$0_
* Этот метод вызывается из внутреннего класса когда тот ссылается на поля внешнего класса.
* Это несет некоторую опасность. Если внутренний класс имеет доступ к закрытым полям, можно создать другой класс, добавить его в тот же пакет и получить доступ к закрытым данным.

\




&#x20;    Если внутренний класс объявлен _**private**_ и тогда его объекты смогут создавать методы только внешнего класса

* Компилятор же считает внутренний класс таким же классом с доступом в пределах пакета
* Компилятор добавляет во внутренний класс private конструктор
* Для вызова закрытого конструктора требуется второй конструктор, доступный в пределах пакета и вызывающий первый

![](https://www.evernote.com/shard/s696/res/bb48fd7a-8fda-42f1-809f-04d038f7a9f0)

* Компилятор преобразует вызов конструктора внутреннего класса из метода внешнего класса следующим образом

\


![](https://www.evernote.com/shard/s696/res/329d662a-732c-45fd-90f1-c1d59bb78ad2)



**2.Локальный внутренний класс (класс в методе)**Если внутренний класс используется лишь однажды в каком либо методе, то его можно определить локально в самом методе\


![](https://www.evernote.com/shard/s696/res/abd03562-dd78-432f-835f-1f7d878cdff5)

* локальные внутренние классы никогда не определяются с помощью модификаторов доступа
* Их область действия всегда ограничивается блоком в котором они объявлены
* Об этом классе известно только методу в котором он объявлен
* Локальный внутренний класс имеет доступ к полям своего внешнего класса и к локальным переменным метода!!
* Но такие локальные переменные должны быть объявлены как final

\




\
\
вызывается метод start()при вызове конструктора внутреннего класса TimePrinter инициализируется объектная переменная listenerПередается ссылка listener конструктору класса Timer, запускается таймер и метод start() прекращает свою работу. В этот момент параметр beep метода start() больше не существует.Некоторое время спустя выполняется оператор if (beep) .... в методе actionPerformed()

![](https://www.evernote.com/shard/s696/res/f790c8c8-0dca-4517-9c99-8fbafec3fe27)

* В локальном классе больше не нужно хранить переменную экземпляра beep
* Он просто ссылается на параметр метода, содержащего переменные своего класса
* Для того чтобы метод actionPerformed() выполнялся успешно, во внутреннем классе должна быть создана копия поля beep до того, как оно перестанет существовать в качестве локальной переменной метода. Именно так и происходит

\


![](https://www.evernote.com/shard/s696/res/117824a4-f4c4-40f2-9e33-d24f3eff2da6)

* Параметр конструктора
* Переменная val$beep
* при создании объекта переменная beep передается конструктору и размещается в поле val$beep
* поэтому нужно гарантировать, что локальная переменная и ее копия, созданная в локальном классе, всегда имеют одно и то же значение (final)

\




\


* переменную счетчика counter нельзя объявлять как final, ее нельзя заменить на Integer поскольку [объекты типа Integer неизменяемы](https://www.ibm.com/developerworks/ru/library/j-jtp02183/index.html), поскольку ее нужно обновлять.
* можно воспользоваться массивом в 1 элемент

![](https://www.evernote.com/shard/s696/res/7ba7d152-ffb9-4476-b201-c5ca532721b7)

* Переменная типа массива объявлена как final, но это просто означает что ее нельзя заставить ссылаться на другой массив. А элементы массива можно свободно изменять.

\
\




**3. Анонимный внутренний класс (локальный класс без имени)**

* Работая с локальными внутренними классами
* Если требуется создать единственный объект некоторого класса

\
\
\
//new ActionListener() { тело анонимного класса};\


![](https://www.evernote.com/shard/s696/res/bf04d5ca-980a-46c4-835a-74a06e6855f8)

![](https://www.evernote.com/shard/s696/res/5d516743-5ad4-4be4-b03f-470285f10469)

* СуперТип может быть интерфейсом, и тогда внутренний класс реализует данный интерфейс
* СуперТип может быть классом, и тогда внутренний класс расширяет суперкласс
* Анонимный внутренний класс не может иметь конструкторов, так как у него нет имени
* Параметры необходимые для создания объекта, передаются в конструктор суперкласса

\


* Следует внимательно различать создание нового объекта некоторого класса и конструированием объекта _**анонимного внутреннего класса**_ расширяющего данный класс.

\


![](https://www.evernote.com/shard/s696/res/96190594-4099-452c-bd59-fcde2fb2f992)



\
\


![](https://www.evernote.com/shard/s696/res/5b31c443-7d64-4ec5-a70d-a61878bd111d)



**4. Статический внутренний класс (Внутренний класс без ссылок на объект внешнего класса)**

* Подавить формирование ссылки на объект внешнего класса можно, объявив внутренний класс статическим static
* Static можно объявить только внутренние классы
* Static класс не содержит ссылку на создавший его объект внешнего класса
* Применяется когда объект внутреннего класса создается в теле статического метода(статический метод выполняется без объекта класса). Если класс Pair не объявить статическим компилятор сообщит, что при инициализации объекта внутреннего класса объект типа ВнешнийКласс недоступен.
* Применяется когда доступ к объекту внутреннего класса не требуется.
* Внутренние классы определенные в интерфейсах , автоматически считаются public static

[Пример](http://www.evernote.com/l/ArgigyzYrXtG\_Je\_XKGDTcwUofTDhwRqzU8/)

![](https://www.evernote.com/shard/s696/res/75c270c6-6ee7-4c09-98f3-c6e43d5099bc)



**5. Proxy -** **класс (Класс посредник** **)**

* Применяются для того ,чтобы создавать во время выполнения программы новые классы, реализующие заданные интерфейсы
* Когда на стадии компиляции еще не известно, какие именно интерфейсы следует реализовать
* Слишком сложно посмотреть позже Хорстман т.1 стр 307 или [здесь](https://www.ibm.com/developerworks/ru/library/j-jtp08305/index.html)
