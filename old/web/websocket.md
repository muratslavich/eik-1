# Websocket

[https://habrahabr.ru/post/79038/](https://habrahabr.ru/post/79038/)

{% embed url="https://www.html5rocks.com/en/tutorials/websockets/basics" %}

**WebSocket** — протокол [полнодуплексной связи](https://ru.wikipedia.org/wiki/%D0%94%D1%83%D0%BF%D0%BB%D0%B5%D0%BA%D1%81\_\(%D1%82%D0%B5%D0%BB%D0%B5%D0%BA%D0%BE%D0%BC%D0%BC%D1%83%D0%BD%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B8\)) (может передавать и принимать одновременно) поверх [TCP](https://ru.wikipedia.org/wiki/TCP)-соединения, предназначенный для обмена сообщениями между браузером и веб-сервером в режиме реального времени.\
Как только ваша страница решила, что она хочет открыть веб сокет на сервер, она создает специальный javascript-объект:\


```
1. <script>
2. ws = new WebSocket("ws://site.com/demo");
3.  
4. // и навешивает на новый объект три колл-бека:
5.  
6. // первый вызовется, когда соединение будет установлено:
7. ws.onopen = function() { alert("Connection opened...") };
8.  
9. // второй - когда соединено закроется
10. ws.onclose = function() { alert("Connection closed...") };
11.  
12. // и, наконец, третий - каждый раз, когда браузер получает какие-то данные через веб-сокет
13. ws.onmessage = function(evt) { $("#msg").append("<p>"+evt.data+"</p>"); };
14.  
15. </script>
```

\
\
Все начинается так же как в обычном HTTP-запросе. Браузер подключается по протоколу TCP на 80 порт сервера и дает немного необычный GET-запрос:GET /demo HTTP/1.1Upgrade: WebSocketConnection: UpgradeHost: site.comOrigin: http://site.com\
Если сервер поддерживает ВебСокеты, то он отвечает таким образом:HTTP/1.1 101 Web Socket Protocol HandshakeUpgrade: WebSocketConnection: UpgradeWebSocket-Origin: http://site.comWebSocket-Location: ws://site.com/demo\
Если браузер это устраивает, то он просто оставляет _TCP-соединение открытым_. Все — «рукопожатие» совершено, канал обмена данными готов.\
Как только одна сторона хочет передать другой какую-то информацию, она отправляет дата-фрейм следующего вида:\
0x00, <строка в кодировке UTF-8>, 0xFF\
Что именно отправлять, разработчики полностью оставили на ваше усмотрение: хотите XML, хотите JSON. Каждый раз, когда браузер будет получать такое сообщение, он будет «дергать» ваш колл-бек onmessage. \
С помощью WebSockets так же можно передавать и бинарные данные. Для них используется другой дата-фрейм следующего вида:\
0x80, <длина - один или несколько байт>, <тело сообщения>\
Чтобы не создавать ограничений на длину передаваемого сообщения и в тоже время не расходовать байты нерационально, разработчики использовали очень хитрый способ указания длины тела сообщения. Каждый байт в указании длины рассматривается по частям: самый старший бит указывает является ли этот байт последним (0) либо же за ним есть другие (1), а младшие 7 битов содержат собственно данные. Обрабатывать можно так: как только вы получили признак бинарного дата-фрейма 0x80, вы берете следующий байт и откладываете его в отдельную «копилку», смотрите на следующий байт — если у него установлен старший бит, то переносите и его в «копилку», и так далее, пока вам не встретится байт с 0 старшим битом. Значит это последний байт в указателе длины — его тоже переносите в «копилку». Теперь из всех байтов в «копилке» убираете старшие биты и слепляете остаток. Вот это и будет длина тела сообщения. Еще можно интерпретировать как 7-битные числа без старшего бита.\
URL WebSocket начинается с ws:// или wss:// (по SSL).\
\
[https://www.ibm.com/developerworks/ru/library/wa-reverseajax2/index.html](https://www.ibm.com/developerworks/ru/library/wa-reverseajax2/index.html)

**На стороне сервера**\
На сервер посылается HTTP-рукопожатие с определенными заголовками. Затем создается нечто вроде сокета на JavaScript на стороне сервера или клиента. Этот сокет можно использовать для асинхронного приема данных через обработчик событий.![Reverse Ajax с WebSockets](https://www.evernote.com/shard/s696/res/3ff92122-7f5f-4453-bd2c-3151d99c4e60)\
\


**JavaScript-код клиента**

```
var ws = new WebSocket('ws://127.0.0.1:8080/async'); 
 ws.onopen = function() { 
     // вызывается при открытии соединения 
 }; 
 ws.onerror = function(e) { 
     // вызывается в случае ошибки, например, при обрыве связи 
 }; 
 ws.onclose = function() { 
     // вызывается при закрытии соединения 
 }; 
 ws.onmessage = function(msg) { 
     // вызывается, когда сервер посылает сообщение клиенту.
     // сообщение содержится в msg.data. 
 }; 
 // Вот как послать некоторые данные на сервер:
 ws.send('some data'); 
 // Как закрыть сокет: 
ws.close();

```

На стороне сервера обработка WebSockets будет немного сложнее. Спецификации Java для стандартной поддержки WebSockets (пока) не существует. Для использования WebSockets-функций Web-контейнера (например, Tomcat или Jetty), нужно тесно связать код приложения с зависящей от контейнера библиотекой, которая позволяет получить доступ к функции WebSockets.\


**Обработчик WebSocket для контейнера Jetty**

```
public final class ReverseAjaxServlet extends WebSocketServlet { 
    @Override 
    protected WebSocket doWebSocketConnect(HttpServletRequest request,
                                           String protocol) { 
        return [...] 
    } 
}
```

В Jetty есть несколько способов обработки рукопожатия WebSocket. Наиболее простой заключается в создании подкласса Jetty WebSocketServlet и реализации метода doWebSocketConnect. Этот метод требует возврата экземпляра интерфейса WebSocket Jetty. Нужно реализовать интерфейс и вернуть своего рода конечную точку, соответствующую соединению WebSocket.\


**Пример реализации WebSocket**

```
class Endpoint implements WebSocket { 

    Outbound outbound; 

    @Override 
    public void onConnect(Outbound outbound) { 
        this.outbound = outbound;    
    } 

    @Override 
    public void onMessage(byte opcode, String data) { 
        // вызывается при получении сообщения 
        // обычно используется этот метод 
    } 

    @Override 
    public void onFragment(boolean more, byte opcode, 
                           byte[] data, int offset, int length) { 
        // когда фрагмент завершен, вызывается OnMessage. 
        // Этот  метод  обычно оставляют пустым. 
    } 

    @Override 
    public void onMessage(byte opcode, byte[] data, 
                          int offset, int length) { 
        onMessage(opcode, new String(data, offset, length)); 
    } 

    @Override 
    public void onDisconnect() { 
        outbound = null; 
    } 
}
```

**Отправка сообщения клиенту**

```
if (outbound != null && outbound.isOpen()) {
    outbound.sendMessage('Hello World !');
}
```

Чтобы отключить клиент и закрыть соединение WebSocket, используется метод outbound.disconnect();\


#### **Преимущества**

WebSockets предоставляет мощный способ организации двусторонней связи с короткой задержкой и простой обработкой ошибок. При этом не создается большого числа соединений, как при ждущем опросе Comet, и исключаются недостатки потоковой связи Comet. API очень прост в использовании и не требует никаких дополнительных уровней, как Comet, которому нужна хорошая библиотека для обработки повторного соединения, тайм-аута, Ajax-запросов, рукопожатий, и, возможно, различных способов передачи (ждущий опрос Ajax и опрос jsonp).\


#### **Недостатки**

* поддержка не во всех браузерах, так как это новая спецификация HTML5;
* отсутствие ограничения срока жизни запроса. Так как WebSockets – это TCP-сокет, а не HTTP-запрос, нельзя легко использовать сервисы, ограниченные одним запросом (request-scoped services), такие как SessionInViewFilter из Hibernate. Hibernate ― это среда персистентности, которая предоставляет фильтр для среды HTTP-запроса. В начале запроса объект context (содержащий транзакции и JDBC-соединение) bound настраивается на поток запроса. В конце запроса фильтр уничтожает этот context.

### FlashSockets

Для браузеров, не поддерживающих WebSockets, некоторые библиотеки позволяют прибегнуть к FlashSockets (сокеты через Flash). Эти библиотеки обычно предоставляют тот же официальный API WebSocket, но реализуют его путем делегирования вызовов скрытому Flash-компоненту, включенному в Web-сайт.\


#### Потоки и неблокирующий ввод/вывод

\
Как правило, Web-сервер связывает с каждым входящим HTTP-соединением один поток, или один процесс. Это соединение может быть постоянным (keep-alive), так что через него может поступать множество запросов. В примере для этой статьи это поведение можно изменить, настроив Web-сервер Apache с помощью моделей mpm\_fork или mpm\_worker. Java-Web-серверы (включая серверы приложений, что то же самое), как правило, используют по одному потоку для каждого входящего соединения.\
Размножение потоков приводит к разбазариванию памяти и ресурсов, так как нельзя гарантировать, что все порожденные потоки будут использоваться. Может оказаться, что через установленное соединение не передается никаких данных ни от клиента, ни от сервера. Используется ли этот поток или нет, он потребляет память и ресурсы процессора для планирования и переключателей контекста. При этом при настройке сервера с использованием потоковой модели, как правило, нужно настраивать пул потоков, задавая максимальное количество потоков для обработки входящих соединений. Если это значение указано неправильно или выбрано слишком малым, вы столкнетесь с проблемой дефицита потоков; запросы будут ожидать освобождения потока для своей обработки. После достижения максимального числа одновременных соединений отклик становится замедленным. С другой стороны, установка слишком большого значения может привести к исчерпанию памяти. Слишком большое число потоков займет всю кучу JVM и приведет к сбою сервера.\
Недавно в Java появился новый API ввода/вывода, называемый неблокирующим вводом/выводом (non-blocking I/O). Этот API использует селектор, позволяющий избежать привязки нового потока при создании каждого нового HTTP-соединения с сервером. При поступлении данных происходит прием события и для обработки запроса выделяется поток. Это так называемая модель "поток на запрос" (thread-per-request). Она позволяет Web-серверам, таким как WebSphere и Jetty, масштабироваться и обрабатывать большее число подключений пользователей при фиксированном количестве потоков. При одной и той же конфигурации оборудования Web-серверы, работающие в этом режиме, масштабируются гораздо лучше, чем в режиме "поток на соединение" (thread-per-connection).\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
