# нагрузка

**Обеспечение качества**

\- Критерии качества

&#x20;    например: время отклика при нагрузке

\- Оценка соответствия критериям

\- Формальные проверки



**Автоматизация обеспечения качества**

\- Статический анализ кода

\- Тесты

\- Коммит-хуки

\- Непрерывная интеграция



**Подходы к тестированию**

\- черный ящик

&#x20;    ничего не знаем

\- белый ящик

&#x20;    знаем все (свой код тестируем изнутри)



**Unit - тесты**

\- 100% контроль окружения

\- пишут все программисты

\- перед отправкой изменений проверяются самим программистом

\- после коммита изменения проверяются системой Continuous Integration

\- Метрика - покрытие кода тестами



**Функциональное тестирование**

**-** Пишутся для ключевых элементов

\- Все по настоящему

\- Заданы лишь начальные значения

\- Быстрое покрытие

\- Плохое покрытие



**Нагрузочное тестирование**

\- Выдержит ли сервер заявленное число пользователей

\- Выявление наиболее популярных и наиболее редких багов

\- Метрика - максимальное число пользователей в момент времени



Unit тесты позволяют проверять отдельные модули

Стараться систему тестировать на уровне функциональных блоков (модулей)

Заглушки вместо остальных зависимых модулей



Безопасный рефакторинг

Пользоваться через интерфейсы

Тесты позволят узнать о изменениях после рефакторинга

Можно сначала написать тесты а потом функционал для них



Совместимость модулей можно проверить тестами

Защита от повторения багов



TestDrivenDevelopment TDD (пишем тесты раньше функционала)



**Требования к тестам**

**-** Независимость от внешних факторов

\- Независимость от порядка выполнения

\- Зависимость от "боевого" кода

\- Минимум перекрытий

\- Один тест - одна проверка

\- Повторяемость результатов



**Первый тест**

pom.xml

\<dependency>

&#x20;    \<groupId>junit\</groupId>

&#x20;    \<artifactId>junit\</artifactId>

&#x20;    \<version >4.11\</version>

\</dependency>

public class MainTest {

&#x20;   @Before

&#x20;   public void setUp() throws Exception {

&#x20;   }

&#x20;   @After

&#x20;   public void tearDown() throws Exception {

&#x20;   }

&#x20;   @Test

&#x20;   public void testGetString() throws Exception {

&#x20;   // тестируем метод getString(String inputString);

&#x20;   }

}

Junit получит при запуске на вход класс теста и выполнит у этого теста все те функции, которые помечены аннотацией @Test. Кроме того есть возможность завести специальные функции, которые будут выполнены перед каждым тестом и после каждого теста. В @Before можно будет произвести какую-то инициализацию (например если проверяем пользовательский профиль, то можно его создать в @Before). В @After можно произветси "подчистку" того, что осталось от тестов (почистить кеши, удалить пользователя, который был создан в @Before). @After будет выполнен обязательно, вне зависимости от того прошел тест или упал.



**#### Терминология**

\* Assert - проверка соответствия данным условиям

\* import static junit.framework.TestCase.\*;

\* asserEquals / assertNotEquals

\* assertNull / assertNotNull

\* assertTrue / assertNotTrue

\* fail



**Пример простого теста:**

Класс Math с методом getSum, который необходимо протестировать.

public class Math {

&#x20;   private int a;

&#x20;   private int b;

&#x20;   public Math(int a, int b) {

&#x20;       this.a = a;

&#x20;       this.b = b;

&#x20;   }

&#x20;   public int getSum() {

&#x20;       return this.a + this.b;

&#x20;   }

}

Тест для класса Math

public class SimpleTest {

&#x20;   @Test

&#x20;   public void testGetSum() throws Exception {

&#x20;       // Установка

&#x20;       Math math = new Math(3, 2);

&#x20;       // Действие

&#x20;       int result = math.getSum();

&#x20;       // Проверка

&#x20;       assertEquals(5, result);

&#x20;   }

}



**#### TestDoubles - Дублеры**

Например вместо того что бы обращаться к настоящим сервисам, мы будем обращаться к их дублерам.&#x20;

\* Повышение скорости тестов

\* Независимость от окружения

\* Полное покрытие

\* "Свой человек"



\*\* #### Абстракция\*\*

Идея заложенная в абстракцию следующая - мы не должны наружу в интерфейсы выставлять детали реализации внутренности сервиса, который мы пытаемся тестировать. Тем самым мы можем разделить содержательную часть от реализации (например - содержание - проверка пользователя, а реализация этой проверки может быть разная). HashMapContainKey vs isUserExists

Разделение несущественных деталей реализации подпрограммы и характеристик, существенных для корректного ее использования.

Через разбор абстракции мы готовим наш код для того, что бы было удобно работать с дублерами:

\- мы должны переименовать названия методов в интерфейсах на содержательную часть.

\- мы должны сделать так, что бы у нас сервисы не знали (не зависили) друг о друге ничего, кроме интерфейсов.

При работе сервис должен обращаться к интерфейсам другого сервиса, больше знать ничег не должен. Через этот интерфейс сервис должен запрашивать зделать что-то у другого интерфейса сервиса. Такое разделение должно быть не только на уровне организации кода, но мы всегда должны писать так код. Frontend часть ничего не должна знать о DatabaseService и т.д.



\*\* #### TestDoublers - дублеры\*\*

\* Dummy - просто заполнить параметр. Если у нас есть набор полей, который должен быть определен, мы можем просто чем - нибудь их заполнить. Dummy - заполнить хотя бы чем-нибудь в качестве значения.

\* Fake - упрощеная или/и неподходящая для "боевого" сервера с работающей реализацией. Когда мы подставляем вместо настоящего сервиса, некую замену, которая ведет себя похожим образом при этом не является настоящим сервисом.&#x20;

\* Stubs - заглушка для вызовов в тесте, проверяет состояние. Более простая вещь чем Fake. Stub - подстановка не полноценного сервиса, а того который создан для конкретного теста.&#x20;

\* Spies - stub, следящий за информацией о вызовах. Они не просто подкладывают функцию (как stub), а еще следят за тем была она вызвана или нет, в каких условиях и т.д. (позволяет дополнительно контроливать происходящее).&#x20;

\* Mocks - объекты, заменяющие "настоящие" с заранее заданными условиями. Когда мы в тесте говорим, что при вызове определенных функций настоящего сервиса, вместо вызова - сделай другие какие-то определенные действия.&#x20;



\*Dummy\*

@Test

public void testGood() {

// Установка начальных значений

final Frontend frontend = new Frontend();

frontend.registerNewUser("testLogin", "testPassword");

// Действие

int users = frontend.getUserCount();

// Проверка

Assert.equals(users, 1);

}



\*Fake\*

\* InMemory Database: H2 etc.

\* Debug WebServer

\* Свое



\*Stubs\*

Задача - проверить, что бы метод kickAllUsers(); был обязательно вызван.

public class AccountServerStub implements IAccountServer {

private boolean wasExecute;

&#x20;    public void kickAllUsers() {

&#x20;      wasExecute = true;

&#x20;    }

&#x20;    public boolean wasExecute() {

&#x20;      return wasExecute;

&#x20;    }

}

@Test

public void testKickAllUsers() {

&#x20;    final IAccountServer accountServer = new AccountServerStub();

&#x20;    new ShutsownServervice(accountServer).stop("We are closing :(");

&#x20;    Assert.assertTrue(accountServer.wasExecute());

}



\*Spies\*

@Test

public void testKickAllUsers() {

&#x20;    final AccountServer accountServer = new AccountServer();

&#x20;    final AccountServer spyAccountServer = spy(accountServer);

&#x20;    doNothing().when(spyAccountServer).kickAllUsers();

&#x20;    new ShutdownService(accountServer).stop("We are closing :(");

&#x20;    verify(spyAccountServer, times(1)).kickAllUsers();

}



\#### Mockito

Для подключения необходимо в pom прописать зависимость.

\<dependency>

&#x20;    \<groupId>org.mockito\</groupId>

&#x20;    \<artifactId>mockito-all\</artifactId>

&#x20;    \<version>1.8.4\</version>

\</dependency>

public class FrontendTest {

&#x20;   // должны задать mocks для классов, которые будем использовать.

&#x20;   final private static HttpServletRequest request = mock(HttpServletRequest.class);

&#x20;   final private static HttpServletResponse response = mock(HttpServletResponse.class);

&#x20;   @Test

&#x20;   public void testDoGet() throws Exception {

&#x20;       final StringWriter stringWrite = new StringWriter();

&#x20;       when(response.getWriter()).thenReturns(stringWrite);

&#x20;       when(request.getPathInfo()).thenReturn("/login");

&#x20;       //... new frontend ....

&#x20;       frontend.doGet(request, response);

&#x20;       verify(request, atLeastOnce()).getParameter("userName");

&#x20;       Assert.assertTrue(stringWrite.toString().contains("Welcome"));

&#x20;   }

}



\*\* #### Функциональное тестирование\*\*

Функциональное тестирование - это необходимое, но недостаточное условие работоспособности. Практика.

Под собой функциональное тестирование подразумевает целостную проверку системы. Без ФТ мы не можем до конца утвержать, что блоки, которые мы отдельно протестировали, могут вместе выполнять ту задачу, которую мы поставили.&#x20;

\*Функциональные тесты (примеры):

\* Реализуется ли требуемый функционал

\* Поднятие сервера

\* Взаимодействие нескольких модулей

\* Вход в игру



**#### Нагрузочное тестирование**

В первую очередь - это создание некой модели пользователя, т.е. вначале записываем поведение пользователя, усредняем значения и пытаемся воспроизвести поведение.&#x20;

\*Организация нагрузочного тестирования:\*

\* Список активностей пользователей. Что вообще можно делать с системой.

\* Параметры активностей.

\* Реализация бота.

\* Проведение испытания.&#x20;

\* Анализ результатов.

\*Инструменты нагрузочного тестирования:\*

\* jMeter

\* Yandex-tanki

\* Gatling

\* Свое

\#### Результаты нагрузочного тестирования

Необходимо обращать внимание на следующие показатели:

\* Потребление CCU, %

\* Диск (iowait)

\* Сеть, Gb/s

\* Время отклика, ms

\* CCU, users

\* Response time

\* Использование памяти, Gb



&#x20;
